# summarize the fit
summary(reg.model)
#make predictions
predictions <- predict(reg.model, test)
#make predictions
predictions <- predict.lm(reg.model, test)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig +
LandSlope + Neighborhood + Condition1 + BldgType +
HouseStyle + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
RoofStyle + Foundation + BsmtQual + BsmtCond +
BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating + HeatingQC +
CentralAir + FullBath + BedroomAbvGr +
GarageType + GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, test)
# librairies
library(dplyr)
library(ggplot2)
# Chargement
test <- read.csv("C:/Users/utilisateur/Desktop/HousePrices/test.csv")
# Dimensions
dim(test)
# Summary
summary(test)
colSums(is.na(test))
# librairies
library(dplyr)
library(ggplot2)
# Chargement
test <- read.csv("C:/Users/utilisateur/Desktop/HousePrices/test.csv")
# Dimensions
dim(test)
# Summary
summary(test)
colSums(is.na(test))
levels(test$MSZoning)<-c(levels(test$MSZoning),"none")
levels(test$LotFrontage)<-c(levels(test$LotFrontage),"none")
levels(test$Alley)<-c(levels(test$Alley),"none")
levels(test$Utilities)<-c(levels(test$Utilities),"none")
levels(test$Exterior1st)<-c(levels(test$Exterior1st),"none")
levels(test$Exterior2nd)<-c(levels(test$Exterior2nd),"none")
levels(test$MasVnrType)<-c(levels(test$MasVnrType),"none")
levels(test$MasVnrArea)<-c(levels(test$MasVnrArea),"none")
levels(test$BsmtQual)<-c(levels(test$BsmtQual),"none")
levels(test$BsmtCond)<-c(levels(test$BsmtCond),"none")
levels(test$BsmtExposure)<-c(levels(test$BsmtExposure),"none")
levels(test$BsmtFinType1)<-c(levels(test$BsmtFinType1),"none")
levels(test$BsmtFinSF1)<-c(levels(test$BsmtFinSF1),"none")
levels(test$BsmtFinType2)<-c(levels(test$BsmtFinType2),"none")
levels(test$BsmtFinSF2)<-c(levels(test$BsmtFinSF2),"none")
levels(test$BsmtUnfSF)<-c(levels(test$BsmtUnfSF),"none")
levels(test$TotalBsmtSF)<-c(levels(test$TotalBsmtSF),"none")
levels(test$BsmtFullBath)<-c(levels(test$BsmtFullBath),"none")
levels(test$BsmtHalfBath)<-c(levels(test$BsmtHalfBath),"none")
levels(test$KitchenQual)<-c(levels(test$KitchenQual),"none")
levels(test$Functional)<-c(levels(test$Functional),"none")
levels(test$FireplaceQu)<-c(levels(test$FireplaceQu),"none")
levels(test$GarageType)<-c(levels(test$GarageType),"none")
levels(test$GarageYrBlt)<-c(levels(test$GarageYrBlt),"none")
levels(test$GarageFinish)<-c(levels(test$GarageFinish),"none")
levels(test$GarageCars)<-c(levels(test$GarageCars),"none")
levels(test$GarageArea)<-c(levels(test$GarageArea),"none")
levels(test$GarageQual)<-c(levels(test$GarageQual),"none")
levels(test$GarageCond)<-c(levels(test$GarageCond),"none")
levels(test$PoolQC)<-c(levels(test$PoolQC),"none")
levels(test$Fence)<-c(levels(test$Fence),"none")
levels(test$MiscFeature)<-c(levels(test$MiscFeature),"none")
levels(test$SaleType)<-c(levels(test$SaleType),"none")
test[is.na(test)] <- "none"
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig +
LandSlope + Neighborhood + Condition1 + BldgType +
HouseStyle + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
RoofStyle + Foundation + BsmtQual + BsmtCond +
BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating + HeatingQC +
CentralAir + FullBath + BedroomAbvGr +
GarageType + GarageArea + SaleType + SaleCondition + FireplaceQu + PoolQC, data=datareg)
predictions <- predict.lm(reg.model, test)
realpredictions <- exp(predictions)
realpredictions
#make predictions
predictions <- predict.lm(reg.model, test)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig +
LandSlope + Neighborhood + Condition1 + BldgType +
HouseStyle + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
RoofStyle + Foundation + BsmtQual + BsmtCond +
BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating + HeatingQC +
CentralAir + FullBath + BedroomAbvGr +
GarageType + GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, test)
# librairies
library(dplyr)
library(ggplot2)
library(FactoMineR)
library(factoextra)
# Chargement
test <- read.csv("C:/Users/utilisateur/Desktop/HousePrices/test.csv")
# Dimensions
dim(test)
# Summary
summary(test)
# Ah... Il y a beaucoup de donnÃ©es manquantes.
# Combien par colonne?
# nb de donnees manquantes par colonne
colSums(is.na(test))
# Etude des attributs rares et leur impact sur SalesPrice
# RÃ©cupÃ©ration des colonnes avec NA > 300
AttributRare<-train[,c(which(colSums(is.na(train))>300),82)]
head(AttributRare)
summary(AttributRare)
# La valeur NA dans ces colonnes porte une information
# importante : absence de la feature!
# REmplaÃ§ons par "none"
levels(AttributRare$Alley)<-c(levels(AttributRare$Alley),"none")
levels(AttributRare$Alley)<-c(levels(AttributRare$Alley),"none")
levels(AttributRare$FireplaceQu)<-c(levels(AttributRare$FireplaceQu),"none")
levels(AttributRare$PoolQC)<-c(levels(AttributRare$PoolQC),"none")
levels(AttributRare$Fence)<-c(levels(AttributRare$Fence),"none")
levels(AttributRare$MiscFeature)<-c(levels(AttributRare$MiscFeature),"none")
AttributRare[is.na(AttributRare)] <- "none"
# Etude des attributs rares et leur impact sur SalesPrice
# RÃ©cupÃ©ration des colonnes avec NA > 300
AttributRare<-test[,c(which(colSums(is.na(test))>300),82)]
# Etude des attributs rares et leur impact sur SalesPrice
# RÃ©cupÃ©ration des colonnes avec NA > 300
AttributRare<-test[,c(which(colSums(is.na(test))>300),80)]
head(AttributRare)
summary(AttributRare)
levels(AttributRare$Alley)<-c(levels(AttributRare$Alley),"none")
levels(AttributRare$FireplaceQu)<-c(levels(AttributRare$FireplaceQu),"none")
levels(AttributRare$PoolQC)<-c(levels(AttributRare$PoolQC),"none")
levels(AttributRare$Fence)<-c(levels(AttributRare$Fence),"none")
levels(AttributRare$MiscFeature)<-c(levels(AttributRare$MiscFeature),"none")
AttributRare[is.na(AttributRare)] <- "none"
# On passe Ã  l'autre partie du jeu de donnÃ©es
# Elimination des colonnes avec NA > 300
Test<-test[,which(colSums(is.na(test))<300)]
dim(Test)
Test<-Test[complete.cases(Test),]
# Nombre de lignes restantes entiÃ¨res
# aprÃ¨s Ã©limination
# des colonnes avec donnÃ©es manquantes
length(which(complete.cases(TrainFull)==T))
# RÃ©cupÃ©ration des colonnes numÃ©riques
trainNum<-select_if(TrainFull, is.numeric)
(which(complete.cases(Test)==T))
# Nombre de lignes restantes entiÃ¨res
# aprÃ¨s Ã©limination
# des colonnes avec donnÃ©es manquantes
length(which(complete.cases(Test)==T))
testNum<-select_if(Test, is.numeric)
dim(testNum)
# Summary
summary(testNum)
# Jeter un coup d'oeil aux variables avec
# Beaucoup de zÃ©ros
colSums(testNum == 0, na.rm=T)
# Var. quali : MoSold. Solution : Ã©liminer de l'ACP,
#              Etudier Ã  part logSalePrice en fonction de MoSold
#              Ou de MoSold rÃ©parti en saisons plus grossiÃ¨res
testNum$MoSoldFac<-factor(testNum$MoSold)
colSums(testNum == 0, na.rm=T)
dataACP<-testNum[,c(which(colSums(testNum == 0, na.rm=T)<300))]
dataACP<-select(dataACP, -MoSold,-MoSoldFac, -Id)
dim(dataACP)
# ACP
cor(dataACP)
res.pca<-PCA(dataACP)
# Régression
Test<-test[,which(colSums(is.na(train))<300)]
Test<-test[,which(colSums(is.na(test))<300)]
testreg<-data.frame(Test,AttributRare[,-ncol(AttributRare)])
testreg<-testreg[,c(which(colSums(testreg == 0, na.rm=T)<300))]
testreg$MoSoldFac<-factor(testreg$MoSold)
testreg<-select(testreg, -Id,-MoSold)
# Oups certaines colonnes sont constantes.
# La fonction suivante permet de les détecter facilement
library(caret)
nearZeroVar(testreg, saveMetrics=T)
datareg<-select(testreg, -Utilities)
testreg<-select(testreg, -Utilities)
testreg<-select(testreg, -GrLivArea, -GarageCars, -X1stFlrSF,-GarageYrBlt,-TotRmsAbvGrd)
testreg<-select(testreg, -Electrical, -Exterior1st)
# Virons MSSubClass
testreg<-select(testreg, -MSSubClass)
# librairies
library(dplyr)
library(ggplot2)
library(FactoMineR)
library(factoextra)
# Chargement
train <- read.csv("C:/Users/utilisateur/Desktop/HousePrices/trainfull.csv")
# Dimensions
dim(train)
# Summary
summary(train)
# Ah... Il y a beaucoup de donnÃ©es manquantes.
# Combien par colonne?
# nb de donnees manquantes par colonne
colSums(is.na(train))
# Je me rends compte que les colonnes avec beaucoup de NA
# correspondent Ã  la prÃ©sence/l'absence d'un attribut particulier
# dans la maison. Il serait intÃ©ressant de mettre ces colonnes
# A part pour en faire une analyse hors-ACP, parce que
# dans l'ACP, toute ligen avec au moins un NA est Ã©liminÃ©e.
# Cependant, l'analyse de ces prÃ©sence/absence d'attribut
# peut Ãªtre trÃ¨s intÃ©ressante d'un point de vue explication/prÃ©diction
# de SalesPrice
# Etude de SalePrice
hist(train$SalePrice)
# Il y a une queue de distribution sur la droite
# == il y a certaines maisons beaucoup trop chÃ¨res
# comparÃ©es aux autres
# Statistiquement il est plus intÃ©ressant de travailler
# sur des donnÃ©es normales (ou gaussiennes)
# Transformation des donnÃ©es
train$logSalePrice<-log(train$SalePrice)
hist(log(train$SalePrice))
# Etude des attributs rares et leur impact sur SalesPrice
# RÃ©cupÃ©ration des colonnes avec NA > 300
AttributRare<-train[,c(which(colSums(is.na(train))>300),82)]
head(AttributRare)
summary(AttributRare)
# La valeur NA dans ces colonnes porte une information
# importante : absence de la feature!
# REmplaÃ§ons par "none"
levels(AttributRare$Alley)<-c(levels(AttributRare$Alley),"none")
levels(AttributRare$FireplaceQu)<-c(levels(AttributRare$FireplaceQu),"none")
levels(AttributRare$PoolQC)<-c(levels(AttributRare$PoolQC),"none")
levels(AttributRare$Fence)<-c(levels(AttributRare$Fence),"none")
levels(AttributRare$MiscFeature)<-c(levels(AttributRare$MiscFeature),"none")
AttributRare[is.na(AttributRare)] <- "none"
# Box plots
qplot(Alley, logSalePrice, data=AttributRare,
geom="boxplot")
qplot(FireplaceQu, logSalePrice, data=AttributRare,
geom="boxplot")
qplot(PoolQC, logSalePrice, data=AttributRare,
geom="boxplot")
qplot(Fence, logSalePrice, data=AttributRare,
geom="boxplot")
qplot(MiscFeature, logSalePrice, data=AttributRare,
geom="boxplot")
# On passe Ã  l'autre partie du jeu de donnÃ©es
# Elimination des colonnes avec NA > 300
TrainFull<-train[,which(colSums(is.na(train))<300)]
dim(TrainFull)
TrainFull<-TrainFull[complete.cases(TrainFull),]
# Nombre de lignes restantes entiÃ¨res
# aprÃ¨s Ã©limination
# des colonnes avec donnÃ©es manquantes
length(which(complete.cases(TrainFull)==T))
# RÃ©cupÃ©ration des colonnes numÃ©riques
trainNum<-select_if(TrainFull, is.numeric)
dim(trainNum)
# Summary
summary(trainNum)
# JE me rends compte qu'il y a pas mal de
# 3rd Quartile Ã  zÃ©ro. Cela dÃ©note
# des variables avec beaucoup de zÃ©ro.
# Jeter un coup d'oeil aux variables avec
# Beaucoup de zÃ©ros
colSums(trainNum == 0, na.rm=T)
# Var. dÃ©jÃ  exploitÃ©es : PoolArea, MiscVal, FirePlaces.
# On les Ã©limine.
# Var. qui dÃ©pendent de la prÃ©sence/absence d'une
# feature : ScreenPorch, X3SsnPorch, EnclosedPorch,
#           OpenPorchSF, WoodDeckSF, HalfBath, BsmtHalfBath
#           LowQualFinSF, BsmtFullBath, BsmtFinSF2, BsmtFinSF1
# Solution 1: transformer en prÃ©sence/absence de feature
#             et dessiner des boxplots de logSalesPrce
#             en fonction de chaque feature binarisÃ©e,
#             puis Ã©liminer les colonnes pour l'ACP'
# Solution 2: crÃ©er des classes de score pour chaque feature
#             exemple : 0 pour 0, 1 pour 0 Ã  150, 2 pour 150 Ã 
#             + l'infini. DÃ©finir les intervalles en se basant
#             sur les mÃ©dianes/quartiles. Faire des boxplots aussi.
# Var. quali : MoSold. Solution : Ã©liminer de l'ACP,
#              Etudier Ã  part logSalePrice en fonction de MoSold
#              Ou de MoSold rÃ©parti en saisons plus grossiÃ¨res
trainNum$MoSoldFac<-factor(trainNum$MoSold)
qplot(MoSoldFac, logSalePrice, data=trainNum,
geom=c("violin","boxplot"))
qplot(MoSold, logSalePrice, data=trainNum,
geom=c("point", "smooth"))
# Eliminer toutes les colonnes avec >>0 pour l'ACP
# Elimination Ã©galement des MoSold et MoSoldFac
colSums(trainNum == 0, na.rm=T)
dataACP<-trainNum[,c(which(colSums(trainNum == 0, na.rm=T)<300))]
dataACP<-select(dataACP, -MoSold,-MoSoldFac, -Id, -SalePrice)
dim(dataACP)
# ACP
cor(dataACP)
res.pca<-PCA(dataACP)
fviz_pca_var(res.pca, select.var=list(contrib=10),repel=T)
# Un faisceau de variables liées aux garages est corrélé à logSalePrice
# Colorons par quartier, sur un biplot
fviz_pca_biplot(res.pca,select.var=list(contrib=10),
select.ind=list(contrib=200),
label="var",
col.ind=TrainFull$Neighborhood)
# Dimensions 3 et 4:
fviz_pca_biplot(res.pca, axes=c(3,4), select.var=list(contrib=10),
select.ind=list(contrib=200),
label="var",
col.ind=TrainFull$Neighborhood)
# Régression
TrainFull<-train[,which(colSums(is.na(train))<300)]
datareg<-data.frame(TrainFull,AttributRare[,-ncol(AttributRare)])
datareg<-datareg[,c(which(colSums(datareg == 0, na.rm=T)<300))]
datareg$MoSoldFac<-factor(datareg$MoSold)
datareg<-select(datareg, -Id,-MoSold,-SalePrice)
reg1<-lm(logSalePrice~., data=datareg)
# Oups certaines colonnes sont constantes.
# La fonction suivante permet de les détecter facilement
library(caret)
nearZeroVar(datareg, saveMetrics=T)
datareg<-select(datareg, -Utilities)
reg1<-lm(logSalePrice~., data=datareg)
# Checkons les VIF
library(car)
vif(reg1)
# Oups des variables aliasées ont été détectées. Pas bien.
# Variables aliasées = variables sensiblement identiques à une addition ou une multiplication prÃ¨s
# Le script suivant permet d'éliminer les redondances
alias(reg1)
# Variables numériques
dataNum<-select_if(datareg, is.numeric)
matrice.cor <- cor(dataNum, use = "pairwise.complete.obs")
library(corrplot)
corrplot(matrice.cor, method="circle", tl.cex=0.5)
# findCorrelation (ci-dessous) fait partie du package caret
correlations.fortes <- findCorrelation(matrice.cor, cutoff = 0.6)
colnames(dataNum)[correlations.fortes]
# On élimine les colonnes correspondantes dans le jeu de donnÃ©es
datareg<-select(datareg, -GrLivArea, -GarageCars, -X1stFlrSF,-GarageYrBlt,-TotRmsAbvGrd)
# On relance la rÃ©gression + VIF
reg1<-lm(logSalePrice~., data=datareg)
# Checkons les VIF
vif(reg1)
# Ã§a ne marche toujours pas :(
summary(reg1)
# Aaah au fait les alias concernent des variables quali: Exterior1st
# Et Electrical
datareg<-select(datareg, -Electrical, -Exterior1st)
reg1<-lm(logSalePrice~., data=datareg)
# Checkons les VIF
vif(reg1)
# Virons MSSubClass
datareg<-select(datareg, -MSSubClass)
reg1<-lm(logSalePrice~., data=datareg)
summary(reg1)
# La fonction Anova est plus pratique pour
# Tester la significativitÃ© des var. explicatives catégorielles
library(car)
Anova(reg1)
# Pour voir la direction de l'influence d'une var quanti sur la var. à expliquer,
# Regarder les coefficients du summary.
# Pour visualiser la direction de l'influence d'une catégorielle, faites des boxplot.
# Exemple pour MSZoning
library(ggplot2)
qplot(MSZoning, logSalePrice, data=datareg,
geom="boxplot")
# Diagnostic
plot(reg1, 1)
# Les observations 826 et 633 sont trop turbulentes
# Eventuellement les éliminer et reprendre le calcul
# Autres outils de rÃ©gression: voir fiches résumé page 18
colSums(is.na(test))
colSums(is.na(testreg))
levels(testreg$MSZoning)<-c(levels(testreg$MSZoning),"none")
levels(testreg$LotFrontage)<-c(levels(testreg$LotFrontage),"none")
levels(testreg$Alley)<-c(levels(testreg$Alley),"none")
levels(testreg$Utilities)<-c(levels(testreg$Utilities),"none")
levels(testreg$Exterior1st)<-c(levels(testreg$Exterior1st),"none")
levels(testreg$Exterior2nd)<-c(levels(testreg$Exterior2nd),"none")
levels(testreg$MasVnrType)<-c(levels(testreg$MasVnrType),"none")
levels(testreg$MasVnrArea)<-c(levels(testreg$MasVnrArea),"none")
levels(testreg$BsmtQual)<-c(levels(testreg$BsmtQual),"none")
levels(testreg$BsmtCond)<-c(levels(testreg$BsmtCond),"none")
levels(testreg$BsmtExposure)<-c(levels(testreg$BsmtExposure),"none")
levels(testreg$BsmtFinType1)<-c(levels(testreg$BsmtFinType1),"none")
levels(testreg$BsmtFinSF1)<-c(levels(testreg$BsmtFinSF1),"none")
levels(testreg$BsmtFinType2)<-c(levels(testreg$BsmtFinType2),"none")
levels(testreg$BsmtFinSF2)<-c(levels(testreg$BsmtFinSF2),"none")
levels(testreg$BsmtUnfSF)<-c(levels(testreg$BsmtUnfSF),"none")
levels(testreg$TotalBsmtSF)<-c(levels(testreg$TotalBsmtSF),"none")
levels(testreg$BsmtFullBath)<-c(levels(testreg$BsmtFullBath),"none")
levels(testreg$BsmtHalfBath)<-c(levels(testreg$BsmtHalfBath),"none")
levels(testreg$KitchenQual)<-c(levels(testreg$KitchenQual),"none")
levels(testreg$Functional)<-c(levels(testreg$Functional),"none")
levels(testreg$FireplaceQu)<-c(levels(testreg$FireplaceQu),"none")
levels(testreg$GarageType)<-c(levels(testreg$GarageType),"none")
levels(testreg$GarageYrBlt)<-c(levels(testreg$GarageYrBlt),"none")
levels(testreg$GarageFinish)<-c(levels(testreg$GarageFinish),"none")
levels(testreg$GarageCars)<-c(levels(testreg$GarageCars),"none")
levels(testreg$GarageArea)<-c(levels(testreg$GarageArea),"none")
levels(testreg$GarageQual)<-c(levels(testreg$GarageQual),"none")
levels(testreg$GarageCond)<-c(levels(testreg$GarageCond),"none")
levels(testreg$PoolQC)<-c(levels(testreg$PoolQC),"none")
levels(testreg$Fence)<-c(levels(testreg$Fence),"none")
levels(testreg$MiscFeature)<-c(levels(testreg$MiscFeature),"none")
levels(testreg$SaleType)<-c(levels(testreg$SaleType),"none")
testreg[is.na(testreg)] <- "none"
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig +
LandSlope + Neighborhood + Condition1 + BldgType +
HouseStyle + OverallQual + OverallCond + YearBuilt + YearRemodAdd +
RoofStyle + Foundation + BsmtQual + BsmtCond +
BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating + HeatingQC +
CentralAir + FullBath + BedroomAbvGr +
GarageType + GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
# summarize the fit
summary(reg.model)
vif(reg.model)
#make predictions
predictions <- predict.lm(reg.model, test)
fit <- step(reg.model)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle + Foundation +
BsmtQual + BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr + GarageType +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, test)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle +
BsmtQual + BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr + GarageType +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, test)
#make predictions
predictions <- predict.lm(reg.model, testreg)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle + BsmtExposure + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr + GarageType +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, testreg)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr + GarageType +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, testreg)
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, testreg)
# list types for each attribute
sapply(datareg, class)
# list types for each attribute
sapply(testreg, class)
# list types for each attribute
sapply(datareg, class)
testreg$BsmtUnfSF <- as.numeric(testreg$BsmtUnfSF)
# list types for each attribute
sapply(testreg, class)
testreg$BsmtUnfSF <- as.integer(testreg$BsmtUnfSF)
testreg$BsmtUnfSF <- as.integer(testreg$BsmtUnfSF)
testreg$TotalBsmtSF <- as.integer(testreg$TotalBsmtSF)
testreg$GarageArea <- as.integer(testreg$GarageArea)
testreg$BsmtUnfSF <- as.integer(testreg$BsmtUnfSF)
testreg$TotalBsmtSF <- as.integer(testreg$TotalBsmtSF)
testreg$GarageArea <- as.integer(testreg$GarageArea)
# list types for each attribute
sapply(testreg, class)
View(testreg)
testreg$BsmtUnfSF <- testreg$BsmtUnfSF[is.na(testreg$BsmtUnfSF)] = 0
testreg$BsmtUnfSF<-testreg$BsmtUnfSF[is.na(testreg$BsmtUnfSF)] = 0
testreg$BsmtUnfSF<-[is.na(testreg$BsmtUnfSF)] = 0
testreg$BsmtUnfSF[is.na(testreg$BsmtUnfSF)] = 0
testreg$BsmtUnfSF[is.na(testreg$BsmtUnfSF)] = 0
testreg$TotalBsmtSF[is.na(testreg$TotalBsmtSF)] = 0
testreg$GarageArea[is.na(testreg$GarageArea)] = 0
reg.model <- lm(logSalePrice ~ LotArea + Street + LandContour + LotConfig + LandSlope +
Neighborhood + Condition1 + BldgType + HouseStyle + OverallQual +
OverallCond + YearBuilt + YearRemodAdd + RoofStyle + BsmtUnfSF + TotalBsmtSF + Heating +
HeatingQC + CentralAir + FullBath + BedroomAbvGr +
GarageArea + SaleCondition + FireplaceQu + PoolQC, data=datareg)
#make predictions
predictions <- predict.lm(reg.model, testreg)
realpredictions <- exp(predictions)
realpredictions
test$SalePrice <- realpredictions
nrow(test)
length(realpredictions)
setwd("C:/Users/utilisateur/Desktop/HousePrices")
prediction<-data.frame(realpredictions)
write.csv(predicition, "predictions.csv", row.names=FALSE, sep="t",dec=",", na=" ")
write.csv(predicition, "predictions.csv")
prediction<-data.frame(realpredictions)
write.csv(predicition, "predictions.csv")
prediction
write.csv(predicition, "predictions.csv")
write.csv(prediction, "predictions.csv")
featurePlot(x=x, y=y, plot="ellipse")
setwd("C:/Users/utilisateur/Desktop/HousePrices")
#on crée un dataframe avant de le sauver
trainfull_1<-data.frame(datareg)
# on utilise la fonction write.table, voir ?write.table
# ne pas oublier le .csv à la fin du nom du fichier excel "data.csv"
write.csv(trainfull_1, "trainfull.csv")
test_1<-data.frame(testreg)
write.csv(test_1, "test.csv")
